#ifndef MAIN_CPP
#define MAIN_CPP

/*
 *  MAIN.h
 *  PSC
 *
 *  Created by Pierre-David Letourneau on 3/6/11.
 *  Copyright 2011 Stanford University. All rights reserved.
 *
 *  Overstructure.
 */

#include <vector>
#include <complex>
#include <iostream>

#include "Coordinates.h"
#include "IncWave.h"
#include "Scatterer.h"
#include "Distributions.h"
#include "PSCEnv.h"
#include "ElasticCoordChange.h"
#include "Solver.h"
#include "Finalize.h"

int main(int argc,char **args)
{

  // Display relevant information concerning the problem
  cout << endl << endl;
  cout << "RTOL : " << RTOL << endl;
  cout << "MAXITS : " << MAXITS << endl;
  cout << "OMEGA : " << OMEGA << endl;
  cout << "LAMBDA_OUT : " << LAMBDA_OUT << endl;
  cout << "MU_OUT : " << MU_OUT << endl;
  cout << "C_L_OUT : " << C_L_OUT << endl;
  cout << "C_T_OUT : " << C_T_OUT << endl;
  cout << "K_L_OUT : " << K_L_OUT << endl;
  cout << "K_T_OUT : " << K_T_OUT << endl;
  cout << "NScat : " << NScat << endl;
  cout << "RADIUS : " << RADIUS << endl;
  cout << "nLevels : " << nLevels << endl;
  cout << "EPS : " << EPS << endl;

  cout << endl;


  // PSC environment for fast algorithm
  PSC_Env PSC_env(nLevels, EPS); 

  // Linear solver
  Solver solver; 


  // TODO: Should not have different instances of Index
  Indexing Index(LMAX_VSWF);

  // MPI setup for parallel computing
  int rank, size;
  MPI_Init(&argc, &args);
  MPI_Comm_size(MPI_COMM_WORLD, &size ); 
  MPI_Comm_rank(MPI_COMM_WORLD, &rank );
  cout << "Number of processes : " << size << endl;


  // Construct scatterers
  cout << "***Building scatterers..." << endl;
  std::vector<Scatterer> ScL = ScatInit( NScat, K_L, K_T, K_L_OUT, K_T_OUT );
  cout << "***Building scatterers: done" << endl << endl;


  
  // Construct PSC environment
  cout << "***Constructing environment..." << endl;
  PSC_env.Construct(K_L_OUT, K_T_OUT, ScL);
  cout << "***Constructing environment: done" << endl << endl;



  // Construct sources 
  cout << endl << "***Constructing sources..." << endl;
  int N_s = 1;                       // Number of sources
  int M = ceil((2.*N_s+1)/size);
  double* r_s = new double[M];
  
  // Scatter work among processes
  int N = M * size;
  double* sources = new double[N];
  if( rank == 0 )
    for( int k = 0; k < N; k++)
      sources[k] = (k-N_s)*0.612e-3;

  cout <<  "***Constructing sources: done" << endl << endl;


  
  // Distribute problems for different sources among processes
  MPI_Scatter(&sources[0], M, MPI_DOUBLE, &r_s[0] , M, MPI_DOUBLE, 0, MPI_COMM_WORLD);
  
  int Z = M;
  if( rank == (size-1) )
  Z = (2*N_s+1) - rank*M;
  // *** HACK
  Z = 1;



  cout << "***Computing solution..." << endl;
  for( int m = 0; m < Z; m++ ){
    int Proc_Idx = rank*M + m;  // MPI process index
    
    cout << "   ***Initializing source (plane wave)..." << endl;
    // Initialization of source (plane waves)
    std::string src_type("PW");
    Pvec direction(1./sqrt(2.), 1./sqrt(2.), 0.,Pvec::Cartesian);                // Direction of propagation
    double long_comp = 1.;
    Pvec perp_comp(-1., 1., 0.5, Pvec::Cartesian);          // Shear component perpendicular to direction of propagation 
    //IncWave* IW = new PlaneWave(solver.getECC(), K_L_OUT, K_T_OUT, direction, long_comp, perp_comp);   

    Pvec location(0., 0., 0.,Pvec::Cartesian); 
    IncWave* IW = new PointWave(solver.getECC(),  K_L_OUT, K_T_OUT, direction, location); 

    cout << "   ***Initializing source: done" << endl << endl;
	

    // Initialization of right-hand side
    cout << "   ***Initializing right-hand side..." << endl;
    std::vector< std::vector<complex > > RHS_0(NScat, std::vector<complex >(Index.size()));    // Multipole coefficients for curl VSWF
    std::vector< std::vector<complex > > RHS_1(NScat, std::vector<complex >(Index.size()));    // Multipole coefficients for curl-curl VSWF
    std::vector< std::vector<complex > > RHS_2(NScat, std::vector<complex >(Index.size()));    // Multipole coefficients for gradient VSWF

    solver.RHSInit( IW, ScL, RHS_0, RHS_1, RHS_2);  
    cout << "   ***Initializing right-hand side: done" << endl << endl;

    /* for( int n = 0; n < NScat; n++ ){
      for( int i = 0; i < Index.size(); i++ )
	cout << RHS_0[n][i] << " : " << RHS_1[n][i] << " : " << RHS_2[n][i] << endl;
      cout << endl;
    }*/
    

    

    // Vectors storing solutions for each kind of wave
    // Convention: 0 -> curl VSWF; 1 -> curl_curl VSWF; 2 -> gradient VSWF; 
    cout << "   ***Solving linear system..." << endl;
    std::vector< std::vector<complex> > u_0(NScat, std::vector<complex>(Index.size()));
    std::vector< std::vector<complex> > u_1(NScat, std::vector<complex>(Index.size()));
    std::vector< std::vector<complex> > u_2(NScat, std::vector<complex>(Index.size()));

    // TODO: send solve to a file
    double res = 1e10, rel_res = 1e10, cond;
    solver.Solve(PSC_env, ScL, RHS_0, RHS_1, RHS_2, u_0, u_1, u_2, res, rel_res, cond);
    cout << "   ***Solving linear system: done" << endl << endl;

    
    // Write information about problem to file
    if( rank == 0){
      cout << "   ***Writing to file..." << endl;

      Write_Info(Proc_Idx, src_type, direction, long_comp, perp_comp, res, rel_res, cond);
      Write_Location(Proc_Idx, ScL);
      Write_Solution( Proc_Idx, Index, u_0, u_1, u_2); // Solution OUTSIDE scatterers

      cout << "   ***Writing to file: done" << endl << endl;
    } 
	
    delete IW;
  }
  cout << "***Constructing solution: done" << endl << endl;


  // Clear memory
  PSC_env.Destruct();;
  delete r_s;
  delete sources;
  MPI_Finalize();

  return 0;
}






#endif
